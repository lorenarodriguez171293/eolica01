<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simuladores Avanzados ‚Äî Matriz Energ√©tica & Energ√≠as</title>

  <!-- Chart.js CDN para gr√°ficos interactivos -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#05060a;
      --card:#0b1220;
      --accent:#1e90ff;
      --muted:#9aa6b2;
      --glass: rgba(255,255,255,0.03);
      --radius:12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#03040a,#071022);color:#e6eef7;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,Arial;}
    header{background:linear-gradient(90deg,var(--accent),#4f46e5);padding:20px;text-align:center;border-bottom-left-radius:16px;border-bottom-right-radius:16px;box-shadow:0 6px 30px rgba(0,0,0,0.6)}
    header h1{margin:0;font-size:1.4rem;letter-spacing:0.2px}
    .container{max-width:1200px;margin:22px auto;padding:16px}
    .grid{display:grid;grid-template-columns: 1fr 420px; gap:18px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); padding:16px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.03); box-shadow:0 10px 30px rgba(2,6,23,0.6)}
    .section-title{display:flex;align-items:center;gap:10px;margin:0 0 8px 0}
    .muted{color:var(--muted);font-size:0.95rem}
    .nav-buttons{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .nav-buttons button, .back-button{background:var(--accent);border:none;color:white;padding:10px 12px;border-radius:8px;cursor:pointer;transition:transform .12s ease; font-weight:600}
    .nav-buttons button:hover{transform:translateY(-3px)}
    .back-button{background:#6b7280}
    .data-list{list-style:none;padding:0;margin:10px 0 0 0}
    .data-item{padding:10px 0;border-bottom:1px dashed rgba(255,255,255,0.03)}
    .source-name{font-weight:700;color:#80b3ff;display:block}
    .percentage{background:rgba(255,255,255,0.04);padding:4px 8px;border-radius:6px;font-size:0.9rem}
    .progress-bar-container{height:12px;background:rgba(255,255,255,0.02);border-radius:6px;overflow:hidden;margin-top:8px}
    .progress-bar{height:100%}
    .gas{background:#e67e22}
    .oil{background:#34495e}
    .hydro{background:#2980b9}
    .nuclear{background:#27ae60}
    .renewable{background:#f1c40f}

    /* Simuladores layout */
    .simulator-area{margin-top:16px}
    .simulator-row{display:flex;gap:16px;flex-wrap:wrap}
    .simulator-canvas{flex:0 0 420px;min-width:280px;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,#061226,#07122a);position:relative}
    .simulator-controls{flex:1;min-width:260px}
    .simulator-control{margin-bottom:12px;background:rgba(255,255,255,0.015);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    label{display:block;font-weight:700;color:var(--muted);font-size:.95rem;margin-bottom:6px}
    input[type="range"], input[type="number"], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef7}
    .simulator-output{margin-top:8px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.35);font-weight:700}

    /* small chart area */
    .chart-wrap{height:220px;padding:8px}

    /* Visual touches */
    .legend-pill{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:.9rem;margin-right:8px}

    footer{margin-top:22px;text-align:center;color:var(--muted);font-size:.9rem}
  </style>
</head>
<body>
  <header>
    <h1>Matriz Energ√©tica y Simuladores Avanzados ‚Äî Argentina üá¶üá∑</h1>
  </header>

  <div class="container">

    <div class="grid">
      <!-- MAIN COLUMN -->
      <div>

        <section id="matriz" class="card">
          <div class="section-title">
            <h2 style="margin:0">üìä Matriz Energ√©tica (Ilustrativa)</h2>
          </div>
          <p class="muted">Distribuci√≥n ilustrativa. Usa los controles para ver c√≥mo cambian las estimaciones en los distintos simuladores.</p>

          <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px">
            <div class="legend-pill">Actualizable</div>
            <div class="legend-pill">Interactividad</div>
            <div class="legend-pill">Responsive</div>
          </div>

          <div style="display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap">
            <div style="flex:1;min-width:180px">
              <ul class="data-list" id="matriz-data-list"></ul>
            </div>
            <div style="width:240px">
              <canvas id="matrizChart" width="240" height="220" style="display:block"></canvas>
            </div>
          </div>

          <div style="margin-top:12px" class="muted">Seleccion√° un simulador abajo para ver ilustraci√≥n, animaciones y gr√°ficas din√°micas.</div>

          <div class="nav-buttons" style="margin-top:14px;">
            <button onclick="showSection('hidro')">üíß Hidroel√©ctrica</button>
            <button onclick="showSection('nuclear')">‚öõÔ∏è Nuclear</button>
            <button onclick="showSection('fotovoltaica')">‚òÄÔ∏è Fotovoltaica</button>
            <button onclick="showSection('eolica')">üå¨Ô∏è E√≥lica</button>
            <button onclick="showSection('biocombustibles')">üå± Biocombustibles</button>
          </div>
        </section>

        <!-- HIDRO -->
        <section id="hidro" class="card simulator-area" style="display:none">
          <button class="back-button" onclick="showSection('matriz')">‚¨ÖÔ∏è Volver</button>
          <h3 style="margin-top:8px">üíß Hidroel√©ctrica ‚Äî Embalse y Turbina</h3>
          <p class="muted">Ondas en el agua, velocidad de flujo y rotaci√≥n de turbina. La animaci√≥n responde al caudal y al nivel.</p>

          <div class="simulator-row" style="margin-top:12px;">
            <div class="simulator-canvas">
              <canvas id="hidroCanvas" width="420" height="260"></canvas>
              <div style="position:absolute;right:8px;top:8px;color:var(--muted);font-size:12px">HIDRO</div>
            </div>

            <div class="simulator-controls">
              <div class="simulator-control">
                <label for="embalse-level">Nivel del Embalse (m)</label>
                <input id="embalse-level" type="range" min="10" max="150" value="75" oninput="onHydroInput(event)">
                <input id="embalse-level-num" type="number" value="75" min="10" max="150" oninput="onHydroInput(event)">
              </div>

              <div class="simulator-control">
                <label for="hydro-caudal">Caudal (Q) m¬≥/s</label>
                <input id="hydro-caudal" type="range" min="10" max="2000" value="200" oninput="onHydroInput(event)">
                <input id="hydro-caudal-num" type="number" value="200" oninput="onHydroInput(event)">
              </div>

              <div class="simulator-control">
                <label for="hydro-eff">Eficiencia (%)</label>
                <input id="hydro-eff" type="range" min="30" max="95" value="85" oninput="onHydroInput(event)">
                <input id="hydro-eff-num" type="number" value="85" oninput="onHydroInput(event)">
              </div>

              <div class="simulator-output" id="hydro-output">Potencia: --</div>

              <div style="margin-top:12px" class="chart-wrap card">
                <canvas id="hidroTimeseries"></canvas>
              </div>
            </div>
          </div>
        </section>

        <!-- NUCLEAR -->
        <section id="nuclear" class="card simulator-area" style="display:none">
          <button class="back-button" onclick="showSection('matriz')">‚¨ÖÔ∏è Volver</button>
          <h3 style="margin-top:8px">‚öõÔ∏è Nuclear ‚Äî N√∫cleo, barras y fisi√≥n</h3>
          <p class="muted">Control de barras, animaci√≥n de fisi√≥n (neutrones, fragmentos) y vibraci√≥n t√©rmica del refrigerante.</p>

          <div class="simulator-row" style="margin-top:12px;">
            <div class="simulator-canvas">
              <canvas id="nuclearCanvas" width="420" height="260"></canvas>
              <div style="position:absolute;right:8px;top:8px;color:var(--muted);font-size:12px">NUCLEAR</div>
            </div>

            <div class="simulator-controls">
              <div class="simulator-control">
                <label for="control-rods">Posici√≥n de Barras de Control (%)</label>
                <input id="control-rods" type="range" min="0" max="100" value="50" oninput="onNuclearInput(event)">
                <input id="control-rods-num" type="number" min="0" max="100" value="50" oninput="onNuclearInput(event)">
              </div>

              <div class="simulator-control">
                <label for="n_thermal">Potencia t√©rmica nominal (MWt)</label>
                <input id="n_thermal" type="number" value="1500" oninput="calcNuclear()">
              </div>

              <div class="simulator-control">
                <label for="n_eff">Eficiencia t√©rmica ‚Üí el√©ctrica (%)</label>
                <input id="n_eff" type="number" value="33" oninput="calcNuclear()">
              </div>

              <div class="simulator-output" id="nuclear-output">Estado: --</div>

              <div style="margin-top:12px" class="chart-wrap card">
                <canvas id="nuclearTimeseries"></canvas>
              </div>
            </div>
          </div>
        </section>

        <!-- FOTOVOLTAICA -->
        <section id="fotovoltaica" class="card simulator-area" style="display:none">
          <button class="back-button" onclick="showSection('matriz')">‚¨ÖÔ∏è Volver</button>
          <h3 style="margin-top:8px">‚òÄÔ∏è Fotovoltaica ‚Äî Paneles & temperatura</h3>
          <p class="muted">Irradiaci√≥n, √°rea de panel y efecto t√©rmico. Animaci√≥n representa ret√≠cula de panel con vibraci√≥n t√©rmica.</p>

          <div class="simulator-row" style="margin-top:12px;">
            <div class="simulator-canvas">
              <canvas id="solarCanvas" width="420" height="260"></canvas>
              <div style="position:absolute;right:8px;top:8px;color:var(--muted);font-size:12px">FOTOVOLTAICA</div>
            </div>

            <div class="simulator-controls">
              <div class="simulator-control">
                <label for="solar-intensity">Irradiaci√≥n (W/m¬≤)</label>
                <input id="solar-intensity" type="range" min="0" max="1200" value="700" oninput="onSolarInput(event)">
                <input id="solar-intensity-num" type="number" value="700" oninput="onSolarInput(event)">
              </div>

              <div class="simulator-control">
                <label for="panel-area">√Årea total (m¬≤)</label>
                <input id="panel-area" type="number" value="10" oninput="calcSolar()">
              </div>

              <div class="simulator-control">
                <label for="panel-eff">Eficiencia panel (%)</label>
                <input id="panel-eff" type="number" value="18" oninput="calcSolar()">
              </div>

              <div class="simulator-control">
                <label for="loss-factor">P√©rdidas & temperatura (%)</label>
                <input id="loss-factor" type="number" value="15" oninput="calcSolar()">
              </div>

              <div class="simulator-output" id="solar-output">Producci√≥n: --</div>

              <div style="margin-top:12px" class="chart-wrap card">
                <canvas id="solarTimeseries"></canvas>
              </div>
            </div>
          </div>
        </section>

        <!-- E√ìLICA -->
        <section id="eolica" class="card simulator-area" style="display:none">
          <button class="back-button" onclick="showSection('matriz')">‚¨ÖÔ∏è Volver</button>
          <h3 style="margin-top:8px">üå¨Ô∏è E√≥lica ‚Äî Aerogenerador din√°mico</h3>
          <p class="muted">Potencia escala con v¬≥; animaci√≥n de palas responde a velocidad de viento.</p>

          <div class="simulator-row" style="margin-top:12px;">
            <div class="simulator-canvas">
              <canvas id="windCanvas" width="420" height="260"></canvas>
              <div style="position:absolute;right:8px;top:8px;color:var(--muted);font-size:12px">E√ìLICA</div>
            </div>

            <div class="simulator-controls">
              <div class="simulator-control">
                <label for="wind-speed">Velocidad (m/s)</label>
                <input id="wind-speed" type="range" min="0" max="40" value="12" oninput="onWindInput(event)">
                <input id="wind-speed-num" type="number" value="12" oninput="onWindInput(event)">
              </div>

              <div class="simulator-control">
                <label for="swept-area">√Årea barrida (m¬≤)</label>
                <input id="swept-area" type="number" value="3000" oninput="calcWind()">
              </div>

              <div class="simulator-control">
                <label for="wind-cp">Cp (%)</label>
                <input id="wind-cp" type="number" value="40" oninput="calcWind()">
              </div>

              <div class="simulator-output" id="wind-output">Potencia: --</div>

              <div style="margin-top:12px" class="chart-wrap card">
                <canvas id="windTimeseries"></canvas>
              </div>
            </div>
          </div>
        </section>

        <!-- BIOCOMBUSTIBLES -->
        <section id="biocombustibles" class="card simulator-area" style="display:none">
          <button class="back-button" onclick="showSection('matriz')">‚¨ÖÔ∏è Volver</button>
          <h3 style="margin-top:8px">üå± Biocombustibles ‚Äî Energ√≠a de biomasa</h3>
          <p class="muted">C√°lculo de energ√≠a √∫til y animaci√≥n simplificada de flujo de biomasa.</p>

          <div class="simulator-row" style="margin-top:12px;">
            <div class="simulator-canvas">
              <canvas id="bioCanvas" width="420" height="260"></canvas>
              <div style="position:absolute;right:8px;top:8px;color:var(--muted);font-size:12px">BIO</div>
            </div>

            <div class="simulator-controls">
              <div class="simulator-control">
                <label for="biomass-kg">Biomasa disponible (kg)</label>
                <input id="biomass-kg" type="number" value="1000" oninput="calcBio()">
              </div>

              <div class="simulator-control">
                <label for="pc-mj">Poder calor√≠fico (MJ/kg)</label>
                <input id="pc-mj" type="number" value="17" oninput="calcBio()">
              </div>

              <div class="simulator-control">
                <label for="bio-eff">Eficiencia del proceso (%)</label>
                <input id="bio-eff" type="number" value="30" oninput="calcBio()">
              </div>

              <div class="simulator-output" id="bio-output">Energ√≠a √∫til: --</div>
            </div>
          </div>
        </section>

      </div>

      <!-- SIDE COLUMN: ayuda / info / peque√±a leyenda -->
      <aside>
        <div class="card">
          <h4 style="margin:0">üîé Informaci√≥n</h4>
          <p class="muted" style="margin-top:8px">Esta demo usa modelos simplificados (f√≠sicas aproximadas) pensados para ense√±anza. No usar para dise√±o de ingenier√≠a sin verificaci√≥n.</p>

          <div style="margin-top:12px">
            <strong>Controles r√°pidos</strong>
            <ul class="muted">
              <li>Us√° los sliders para ver animaciones en tiempo real.</li>
              <li>Las gr√°ficas muestran series simuladas (√∫ltimos segundos).</li>
              <li>Todo es responsive y funciona en m√≥viles.</li>
            </ul>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h4 style="margin:0">üìà Gr√°ficos</h4>
          <p class="muted" style="margin-top:8px">La torta de la matriz es interactiva y refleja los datos proporcionados (editable en el c√≥digo).</p>
          <div style="height:160px;margin-top:8px"><canvas id="tinyMatriz" width="320" height="160"></canvas></div>
        </div>
      </aside>
    </div>

    <footer>Archivo demo ‚Äî simuladores educativos ‚Ä¢ Hecho con canvas + Chart.js</footer>
  </div>

  <script>
  /*******************************************************************
   * Datos iniciales de la matriz (puedes modificarlos aqu√≠)
   *******************************************************************/
  const matrizData = [
    { name: "Gas Natural", percentage: 52.0, class: "gas" },
    { name: "Petr√≥leo y Derivados", percentage: 31.0, class: "oil" },
    { name: "Hidroel√©ctrica", percentage: 4.5, class: "hydro" },
    { name: "Nuclear", percentage: 2.5, class: "nuclear" },
    { name: "Otras Renovables (E√≥lica, Solar, Biomasa)", percentage: 8.0, class: "renewable" },
    { name: "Carb√≥n y Otros", percentage: 2.0, class: "oil" }
  ];

  /*******************************************************************
   * RENDER MATRIZ LIST + Chart.js donut
   *******************************************************************/
  const listContainer = document.getElementById('matriz-data-list');
  function renderMatrizData() {
    listContainer.innerHTML = '';
    matrizData.forEach(item => {
      const li = document.createElement('li');
      li.className = 'data-item';
      li.innerHTML = `
        <span class="source-name">${item.name}</span>
        <div style="display:flex;align-items:center;justify-content:space-between">
          <span class="percentage">${item.percentage.toFixed(1)}%</span>
        </div>
        <div class="progress-bar-container"><div class="progress-bar ${item.class}" style="width:${item.percentage}%;"></div></div>
      `;
      listContainer.appendChild(li);
    });
  }
  renderMatrizData();

  // Chart.js donut principal
  const matrizCtx = document.getElementById('matrizChart').getContext('2d');
  const matrizChart = new Chart(matrizCtx, {
    type: 'doughnut',
    data: {
      labels: matrizData.map(d=>d.name),
      datasets: [{
        data: matrizData.map(d=>d.percentage),
        backgroundColor: ['#e67e22','#34495e','#2980b9','#27ae60','#f1c40f','#7f8c8d'],
        hoverOffset: 8,
        borderWidth: 0
      }]
    },
    options: {
      plugins:{legend:{display:false}},
      responsive:true,
      maintainAspectRatio:false
    }
  });

  // tiny matriz in side column
  new Chart(document.getElementById('tinyMatriz').getContext('2d'), {
    type:'pie',
    data:{labels:matrizData.map(d=>d.name), datasets:[{data:matrizData.map(d=>d.percentage), backgroundColor:['#e67e22','#34495e','#2980b9','#27ae60','#f1c40f','#7f8c8d']}]},
    options:{plugins:{legend:{display:false}},maintainAspectRatio:false}
  });

  /*******************************************************************
   * Helper: show/hide sections
   *******************************************************************/
  function showSection(id){
    const sections = document.querySelectorAll('.simulator-area, #matriz.card');
    sections.forEach(s => s.style.display = 'none');
    if(id === 'matriz' || id === 'matriz' ) {
      document.getElementById('matriz').style.display = 'block';
    } else {
      document.getElementById(id).style.display = 'block';
    }
    window.scrollTo({top:0,behavior:'smooth'});
    // start/stop animations as needed
  }

  /*******************************************************************
   * UTILS: time series manager (keeps last N points)
   *******************************************************************/
  function TimeSeries(maxPoints=60){
    this.max = maxPoints;
    this.data = [];
  }
  TimeSeries.prototype.push = function(val){
    this.data.push(val);
    if(this.data.length>this.max) this.data.shift();
  };

  /*******************************************************************
   * HIDRO: canvas waves + turbine rotation + timeseries chart
   *******************************************************************/
  const hidroCanvas = document.getElementById('hidroCanvas');
  const hCtx = hidroCanvas.getContext('2d');
  let hidroAnimId = null;
  let hidroState = { h:75, Q:200, eff:0.85, theta:0, tseries: new TimeSeries(80) };

  // draw water surface with sine waves, and a turbine wheel rotating
  function drawHidro() {
    const W = hidroCanvas.width, H = hidroCanvas.height;
    hCtx.clearRect(0,0,W,H);

    // background sky/land
    const grad = hCtx.createLinearGradient(0,0,0,H);
    grad.addColorStop(0,'#07142a'); grad.addColorStop(1,'#071022');
    hCtx.fillStyle = grad;
    hCtx.fillRect(0,0,W,H);

    // embalse rectangle (left)
    const waterX = 20, waterY = 40, waterW = Math.max(160, Math.min(320, 260));
    // draw reservoir (left)
    hCtx.fillStyle = '#072b54';
    hCtx.fillRect(waterX, waterY, waterW, H - waterY - 20);

    // draw waves inside reservoir
    const baseY = waterY + (H - waterY - 20) * 0.45; // water level dependent
    const levelFactor = hidroState.h/150; // 0..1
    const waterLevel = waterY + (H - waterY - 80) * (1 - levelFactor);
    const amp = 8 + (hidroState.Q/2000)*30; // amplitude larger for higher Q
    const speed = 0.01 + (hidroState.Q/2000)*0.06;
    // wave shape
    hCtx.beginPath();
    hCtx.moveTo(waterX, H - 20);
    for(let x=waterX; x<=waterX+waterW; x++){
      const relx = (x - waterX) / 20;
      const y = waterLevel + Math.sin(relx * 0.6 + hidroState.theta * speed*12) * (amp * Math.sin(hidroState.theta*0.02) * 0.6 + amp*0.4);
      hCtx.lineTo(x, y);
    }
    hCtx.lineTo(waterX + waterW, H - 20);
    hCtx.closePath();

    // fill water with gradient
    const wGrad = hCtx.createLinearGradient(0, waterY, 0, H);
    wGrad.addColorStop(0,'rgba(54,147,255,0.95)');
    wGrad.addColorStop(1,'rgba(6,18,40,0.95)');
    hCtx.fillStyle = wGrad;
    hCtx.fill();

    // draw pipeline to turbine
    const pipeStartX = waterX + waterW - 6;
    const pipeStartY = waterLevel + 6;
    const pipeToX = W - 70, pipeToY = H - 80;
    hCtx.strokeStyle = '#9aa3a8'; hCtx.lineWidth = 12; hCtx.lineCap = 'round';
    hCtx.beginPath();
    hCtx.moveTo(pipeStartX, pipeStartY);
    hCtx.bezierCurveTo(pipeStartX+40, pipeStartY+6, pipeStartX+160, pipeStartY+20, pipeToX-6, pipeToY-20);
    hCtx.stroke();

    // draw turbine (wheel)
    const twX = pipeToX+10, twY = pipeToY+10;
    hCtx.save();
    hCtx.translate(twX, twY);
    hCtx.rotate(hidroState.theta * 0.06); // rotation speed proportional to theta
    // wheel circle
    hCtx.fillStyle = '#ffcc66';
    hCtx.beginPath(); hCtx.arc(0,0,26,0,Math.PI*2); hCtx.fill();
    // blades
    hCtx.fillStyle = '#223';
    for(let i=0;i<3;i++){
      hCtx.rotate(Math.PI*2/3);
      hCtx.beginPath();
      hCtx.moveTo(4,-6);
      hCtx.quadraticCurveTo(24,-2,32,-10);
      hCtx.lineTo(28,8);
      hCtx.quadraticCurveTo(20,2,4,-6);
      hCtx.fill();
    }
    hCtx.restore();

    // labels
    hCtx.fillStyle = '#9aa6b2'; hCtx.font = '12px Inter, Arial';
    hCtx.fillText(`Nivel h: ${hidroState.h} m`, 26, 22);
    hCtx.fillText(`Caudal Q: ${hidroState.Q} m¬≥/s`, 26, 36);
    hCtx.fillText(`Eficiencia: ${(hidroState.eff*100).toFixed(1)}%`, 26, 50);

    // update theta and timeseries
    // rotational speed approx proportional to sqrt(P) but we'll scale simply with Q*h*eff
    const Pwatts = 1000 * 9.81 * hidroState.Q * hidroState.h * hidroState.eff;
    const Pmw = Pwatts / 1e6;
    hidroState.theta += 0.8 + Math.pow(Math.max(0,Pmw), 0.5) * 0.6;
    hidroState.tseries.push(Pmw);

    // update text output element
    document.getElementById('hydro-output').textContent = `Potencia instant√°nea: ${Pmw.toFixed(3)} MW  (‚âà ${Math.round(Pwatts)} W) - f√≥rmula œÅ¬∑g¬∑Q¬∑h¬∑Œ∑`;

    // draw small turbine power bar
    const barX = W - 140, barY = 12, barW = 112;
    hCtx.fillStyle = 'rgba(255,255,255,0.06)'; hCtx.fillRect(barX, barY, barW, 10);
    hCtx.fillStyle = '#27ae60'; hCtx.fillRect(barX, barY, Math.min(barW, (Pmw/200)*barW), 10);

    hidroAnimId = requestAnimationFrame(drawHidro);
  }

  function onHydroInput(e){
    const levelRange = document.getElementById('embalse-level');
    const levelNum = document.getElementById('embalse-level-num');
    const caudalRange = document.getElementById('hydro-caudal');
    const caudalNum = document.getElementById('hydro-caudal-num');
    const effRange = document.getElementById('hydro-eff');
    const effNum = document.getElementById('hydro-eff-num');

    if(e && e.target){
      if(e.target === levelRange) levelNum.value = levelRange.value;
      if(e.target === levelNum) levelRange.value = levelNum.value;
      if(e.target === caudalRange) caudalNum.value = caudalRange.value;
      if(e.target === caudalNum) caudalRange.value = caudalNum.value;
      if(e.target === effRange) effNum.value = effRange.value;
      if(e.target === effNum) effRange.value = effNum.value;
    }

    hidroState.h = Number(levelRange.value);
    hidroState.Q = Number(caudalRange.value);
    hidroState.eff = Number(effRange.value)/100;
    // ensure animation running
    if(!hidroAnimId) drawHidro();
    updateChartFromSeries(hidroTimeseriesChart, hidroState.tseries.data);
  }

  // timeseries chart for hidro
  const hidroTimeseriesCtx = document.getElementById('hidroTimeseries').getContext('2d');
  const hidroTimeseriesChart = new Chart(hidroTimeseriesCtx, {
    type:'line',
    data:{labels: Array(80).fill(''), datasets:[{label:'Potencia (MW)', data:[], tension:0.25, borderWidth:2, fill:true, backgroundColor:'rgba(39,174,96,0.12)', borderColor:'#27ae60'}]},
    options:{animation:false,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}
  });

  /*******************************************************************
   * NUCLEAR: nucleus + neutrons + fission animation + timeseries
   *******************************************************************/
  const nucCanvas = document.getElementById('nuclearCanvas');
  const nCtx = nucCanvas.getContext('2d');
  let nucAnimId = null;
  let nucState = { rodsPct:50, thermal:1500, eff:0.33, reactorTemp:300, tseries:new TimeSeries(80), neutrons:[], fragments:[] };

  function spawnNeutron(x,y,dir=1){
    const speed = 0.7 + Math.random()*1.2;
    nucState.neutrons.push({x,y,vx:(Math.random()*2-1)*0.6 + dir*speed, vy:(Math.random()*2-1)*0.6, life:200});
  }

  function drawNuclear(){
    const W = nucCanvas.width, H = nucCanvas.height;
    nCtx.clearRect(0,0,W,H);

    // background
    const g = nCtx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#07101a'); g.addColorStop(1,'#04101a');
    nCtx.fillStyle = g; nCtx.fillRect(0,0,W,H);

    // reactor core circle
    const cx = 120, cy = H/2, rCore = 60;
    // core glow depends on reactivity
    const reactivity = 1 + ((50 - nucState.rodsPct)/100); // >1 increases
    const glow = Math.min(1.6, Math.max(0.3, reactivity));
    const coreGrad = nCtx.createRadialGradient(cx,cy,10,cx,cy,rCore*1.4);
    coreGrad.addColorStop(0, `rgba(255,200,60,${0.7*glow})`);
    coreGrad.addColorStop(0.5, `rgba(255,120,20,${0.35*glow})`);
    coreGrad.addColorStop(1, 'rgba(20,20,30,0.8)');
    nCtx.fillStyle = coreGrad;
    nCtx.beginPath(); nCtx.arc(cx,cy,rCore,0,Math.PI*2); nCtx.fill();

    // control rods (visual)
    nCtx.fillStyle = '#2d3748';
    const rodX = 40, rodW = 12;
    for(let i=0;i<3;i++){
      const rx = rodX + i*30;
      const rodH = 120;
      const pos = nucState.rodsPct/100;
      const top = cy - rodH/2 + pos*20;
      nCtx.fillRect(rx, top, rodW, rodH);
    }
    nCtx.fillStyle = '#9aa6b2'; nCtx.font='12px Inter'; nCtx.fillText(`Barras: ${nucState.rodsPct}%`, 20, 26);

    // spawn neutrons probabilistically when reactivity high
    const spawnRate = Math.max(0, (1.0 - nucState.rodsPct/100)*6); // more spawn when rods retracted (low %)
    if(Math.random() < spawnRate*0.1){
      spawnNeutron(cx + (Math.random()*rCore*0.6- rCore*0.3), cy + (Math.random()*rCore*0.6 - rCore*0.3), (Math.random()>0.5?1:-1));
    }

    // update neutrons
    for(let i=nucState.neutrons.length-1;i>=0;i--){
      const p = nucState.neutrons[i];
      p.x += p.vx; p.y += p.vy; p.life--;
      // draw
      nCtx.fillStyle = '#e6eef7';
      nCtx.beginPath(); nCtx.arc(p.x,p.y,2,0,Math.PI*2); nCtx.fill();
      // chance to cause fission near core center
      const dx = p.x - cx, dy = p.y - cy;
      if(Math.hypot(dx,dy) < 18 && Math.random()<0.02 * (2 - nucState.rodsPct/100)){
        // fission event: spawn fragments
        for(let k=0;k<4;k++){
          nucState.fragments.push({x:cx,y:cy,vx:(Math.random()*2-1)*3,vy:(Math.random()*2-1)*3,life:100 + Math.random()*80});
        }
        // remove neutron
        nucState.neutrons.splice(i,1);
      } else if(p.life<=0 || p.x < 0 || p.x>W || p.y<0 || p.y>H){
        nucState.neutrons.splice(i,1);
      }
    }

    // fragments
    for(let i=nucState.fragments.length-1;i>=0;i--){
      const f = nucState.fragments[i];
      f.x += f.vx; f.y += f.vy; f.vx *= 0.995; f.vy *= 0.995; f.life--;
      const alpha = Math.max(0, Math.min(1, f.life/120));
      nCtx.fillStyle = `rgba(255,120,40,${alpha})`;
      nCtx.beginPath(); nCtx.arc(f.x,f.y,4,0,Math.PI*2); nCtx.fill();
      if(f.life<=0) nucState.fragments.splice(i,1);
    }

    // thermal vibration visualization (a grid with jitter)
    const gridX = 260, gridY = 50, cell = 18, cols=7, rows=7;
    // temperature approx scales with reactivity
    const temp = 300 + Math.max(0, (50 - nucState.rodsPct)) * 8;
    for(let gx=0;gx<cols;gx++){
      for(let gy=0;gy<rows;gy++){
        const cx2 = gridX + gx*cell;
        const cy2 = gridY + gy*cell;
        const jitter = Math.sin((performance.now()/1000 + gx*0.6 + gy*0.2)* (0.8 + (temp-300)/200)) * ((temp-300)/12 + 0.5);
        nCtx.fillStyle = `rgba(180,220,255,${0.7 - (temp-300)/700})`;
        nCtx.beginPath(); nCtx.arc(cx2 + jitter, cy2 + jitter, 3 + (temp-300)/140, 0, Math.PI*2); nCtx.fill();
      }
    }
    nCtx.fillStyle = '#9aa6b2'; nCtx.font = '12px Inter';
    nCtx.fillText(`Temp aprox: ${Math.round(temp)} K`, 260, gridY + rows*cell + 16);

    // calculate electrical power
    const reactivityFactor = 1 + ((50 - nucState.rodsPct)/100);
    const thermalAdjusted = Math.max(0, nucState.thermal * reactivityFactor);
    const electricalMW = thermalAdjusted * nucState.eff;
    nucState.tseries.push(electricalMW);

    // output text
    let status = 'Estable';
    if(nucState.rodsPct < 20) status = 'Cr√≠tica (sobreactividad) ‚Äî riesgo';
    else if(nucState.rodsPct > 80) status = 'Inhibida (potencia baja)';
    document.getElementById('nuclear-output').textContent = `Estado: ${status} ‚Äî Potencia el√©ctrica estimada: ${electricalMW.toFixed(2)} MW`;

    // continue animation
    nucAnimId = requestAnimationFrame(drawNuclear);
  }

  function onNuclearInput(e){
    const range = document.getElementById('control-rods');
    const num = document.getElementById('control-rods-num');
    if(e && e.target){
      if(e.target === range) num.value = range.value;
      if(e.target === num) range.value = num.value;
    }
    nucState.rodsPct = Number(range.value);
    nucState.thermal = Number(document.getElementById('n_thermal').value);
    nucState.eff = Number(document.getElementById('n_eff').value)/100;
    if(!nucAnimId) drawNuclear();
    updateChartFromSeries(nuclearTimeseriesChart, nucState.tseries.data);
  }

  const nuclearTimeseriesChart = new Chart(document.getElementById('nuclearTimeseries').getContext('2d'), {
    type:'line',
    data:{labels:[], datasets:[{label:'Potencia (MW)', data:[], tension:0.2, borderColor:'#ffb020', backgroundColor:'rgba(255,176,32,0.08)', fill:true}]},
    options:{animation:false,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}
  });

  /*******************************************************************
   * SOLAR: panel reticle + vibraci√≥n t√©rmica + timeseries
   *******************************************************************/
  const solarCanvas = document.getElementById('solarCanvas');
  const sCtx = solarCanvas.getContext('2d');
  let solarAnimId = null;
  let solarState = { G:700, A:10, eta:0.18, losses:0.15, tseries:new TimeSeries(80), tempEffect:0 };

  function drawSolar(){
    const W = solarCanvas.width, H = solarCanvas.height;
    sCtx.clearRect(0,0,W,H);

    // background sun gradient
    const grad = sCtx.createLinearGradient(0,0,0,H);
    grad.addColorStop(0,'#081126'); grad.addColorStop(1,'#021220');
    sCtx.fillStyle = grad; sCtx.fillRect(0,0,W,H);

    // draw sun
    const sunX = W - 70, sunY = 45;
    const rad = 28 + Math.sin(performance.now()/400)*2;
    sCtx.fillStyle = 'rgba(255,214,90,0.95)';
    sCtx.beginPath(); sCtx.arc(sunX, sunY, rad, 0, Math.PI*2); sCtx.fill();

    // panel grid area
    const gridX = 30, gridY=50, gridW=220, gridH=140;
    sCtx.fillStyle = '#081321'; sCtx.fillRect(gridX, gridY, gridW, gridH);
    // lines
    sCtx.strokeStyle = '#0b63a8'; sCtx.lineWidth = 1.6;
    const cols = 6, rows = 4;
    for(let i=1;i<cols;i++){
      const x = gridX + (i/cols)*gridW;
      sCtx.beginPath(); sCtx.moveTo(x, gridY); sCtx.lineTo(x, gridY+gridH); sCtx.stroke();
    }
    for(let j=1;j<rows;j++){
      const y = gridY + (j/rows)*gridH;
      sCtx.beginPath(); sCtx.moveTo(gridX, y); sCtx.lineTo(gridX+gridW, y); sCtx.stroke();
    }

    // thermal vibration effect: jitter each cell dot
    const temp = 20 + solarState.G/40 + (solarState.G>900?10:0);
    for(let i=0;i<cols;i++){
      for(let j=0;j<rows;j++){
        const cx = gridX + (i+0.5)*(gridW/cols);
        const cy = gridY + (j+0.5)*(gridH/rows);
        const jitter = Math.sin((performance.now()/600 + i*0.8 + j*0.3)) * ((temp-20)/18);
        sCtx.fillStyle = `rgba(10,150,200,${0.9 - (temp-20)/80})`;
        sCtx.beginPath(); sCtx.arc(cx + jitter, cy + jitter, 6 + (temp-20)/40, 0, Math.PI*2); sCtx.fill();
      }
    }

    // compute power
    const P = solarState.G * solarState.A * solarState.eta * (1 - solarState.losses); // W
    solarState.tseries.push(P/1000); // kW

    document.getElementById('solar-output').textContent = `Producci√≥n instant√°nea: ${(P/1000).toFixed(3)} kW ‚Äî (G:${solarState.G} W/m¬≤, A:${solarState.A} m¬≤, Œ∑:${(solarState.eta*100).toFixed(1)}%)`;

    solarAnimId = requestAnimationFrame(drawSolar);
  }

  function onSolarInput(e){
    const r = document.getElementById('solar-intensity');
    const n = document.getElementById('solar-intensity-num');
    if(e && e.target){
      if(e.target === r) n.value = r.value;
      if(e.target === n) r.value = n.value;
    }
    solarState.G = Number(r.value);
    solarState.A = Number(document.getElementById('panel-area').value);
    solarState.eta = Number(document.getElementById('panel-eff').value)/100;
    solarState.losses = Number(document.getElementById('loss-factor').value)/100;
    if(!solarAnimId) drawSolar();
    updateChartFromSeries(solarTimeseriesChart, solarState.tseries.data);
  }

  const solarTimeseriesChart = new Chart(document.getElementById('solarTimeseries').getContext('2d'), {
    type:'line', data:{labels:[], datasets:[{label:'kW', data:[], borderColor:'#0b63a8', backgroundColor:'rgba(11,99,168,0.08)', fill:true}]},
    options:{animation:false,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}
  });

  /*******************************************************************
   * WIND: draw turbine with blades rotating based on wind speed
   *******************************************************************/
  const windCanvas = document.getElementById('windCanvas');
  const wCtx = windCanvas.getContext('2d');
  let windAnimId = null;
  let windState = { v:12, A:3000, Cp:0.4, tseries:new TimeSeries(80), theta:0 };

  function drawWind(){
    const W = windCanvas.width, H = windCanvas.height;
    wCtx.clearRect(0,0,W,H);
    wCtx.fillStyle = '#061026'; wCtx.fillRect(0,0,W,H);

    // draw ground and tower
    wCtx.fillStyle = '#2c3440'; wCtx.fillRect(W/2 - 6, 60, 12, H - 90);
    // nacelle
    wCtx.fillStyle = '#dbe6f0';
    wCtx.fillRect(W/2 - 28, 40, 56, 22);
    // hub center
    const hx = W/2, hy = 50;
    // blades rotation speed ~ v
    windState.theta += 0.02 + windState.v * 0.02;
    // draw three blades
    wCtx.save(); wCtx.translate(hx,hy); wCtx.rotate(windState.theta);
    wCtx.fillStyle = '#ffffff';
    for(let i=0;i<3;i++){
      wCtx.beginPath();
      wCtx.moveTo(0,0);
      wCtx.quadraticCurveTo(110, -12, 190, -8);
      wCtx.quadraticCurveTo(165, 18, 14, 8);
      wCtx.fill();
      wCtx.rotate(Math.PI*2/3);
    }
    wCtx.restore();

    // compute power
    const rho = 1.225;
    let Cp = Math.min(0.59, windState.Cp);
    const Pw = 0.5 * rho * windState.A * Math.pow(windState.v,3) * Cp; // W
    windState.tseries.push(Pw/1000); // kW
    document.getElementById('wind-output').textContent = `Potencia estimada: ${(Pw/1000).toFixed(2)} kW ‚Äî Cp: ${(Cp*100).toFixed(1)}%`;

    windAnimId = requestAnimationFrame(drawWind);
  }

  function onWindInput(e){
    const r = document.getElementById('wind-speed'), n = document.getElementById('wind-speed-num');
    if(e && e.target){
      if(e.target === r) n.value = r.value;
      if(e.target === n) r.value = n.value;
    }
    windState.v = Number(r.value);
    windState.A = Number(document.getElementById('swept-area').value);
    windState.Cp = Number(document.getElementById('wind-cp').value)/100;
    if(!windAnimId) drawWind();
    updateChartFromSeries(windTimeseriesChart, windState.tseries.data);
  }

  const windTimeseriesChart = new Chart(document.getElementById('windTimeseries').getContext('2d'), {
    type:'line', data:{labels:[], datasets:[{label:'kW', data:[], borderColor:'#6ee7ff', backgroundColor:'rgba(110,231,255,0.08)', fill:true}]},
    options:{animation:false,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}
  });

  /*******************************************************************
   * BIO: simple animated conveyor + energy calc
   *******************************************************************/
  const bioCanvas = document.getElementById('bioCanvas');
  const bCtx = bioCanvas.getContext('2d');
  let bioAnimId = null;
  let bioState = { bkgRotate:0 };

  function drawBio(){
    const W = bioCanvas.width, H = bioCanvas.height;
    bCtx.clearRect(0,0,W,H);
    bCtx.fillStyle = '#061218'; bCtx.fillRect(0,0,W,H);

    // conveyor belt
    const beltY = H/2 + 20;
    bCtx.fillStyle = '#1f2937'; bCtx.fillRect(20,beltY-18,W-40,36);
    // moving boxes (biomass)
    bioState.bkgRotate += 2;
    for(let i=0;i<8;i++){
      const x = 30 + ((i*80 + (bioState.bkgRotate)) % (W+80)) - 80;
      bCtx.fillStyle = '#6b3b3b';
      bCtx.fillRect(x, beltY-12, 40, 28);
    }

    // draw plant
    bCtx.fillStyle = '#6b5e2f'; bCtx.fillRect(W-120, 40, 90, 140);
    bCtx.fillStyle = '#9aa6b2'; bCtx.font='12px Inter'; bCtx.fillText('Planta', W-110, 58);

    bioAnimId = requestAnimationFrame(drawBio);
  }

  function calcBio(){
    const b = Number(document.getElementById('biomass-kg').value);
    const pc = Number(document.getElementById('pc-mj').value);
    const eff = Number(document.getElementById('bio-eff').value)/100;
    const E = b * pc * 1e6 * eff;
    document.getElementById('bio-output').textContent = `Energ√≠a √∫til estimada: ${Math.round(E)} J ‚Äî ${(E/3.6e6).toFixed(2)} kWh`;
    if(!bioAnimId) drawBio();
  }

  /*******************************************************************
   * Charts update helper: update datasets with last N points
   *******************************************************************/
  function updateChartFromSeries(chart, series){
    // create labels if needed
    const max = chart.data.datasets[0].data.length || 80;
    chart.data.datasets[0].data = series.slice();
    chart.data.labels = new Array(series.length).fill('');
    chart.update('none');
  }

  /*******************************************************************
   * Create timeseries charts initial objects (empty)
   *******************************************************************/
  // hidroTimeseriesChart created earlier
  // nuclearTimeseriesChart created earlier
  // solarTimeseriesChart created earlier
  // windTimeseriesChart created earlier

  /*******************************************************************
   * Inicializaci√≥n al cargar la p√°gina
   *******************************************************************/
  document.addEventListener('DOMContentLoaded', () => {
    // set initial values & event listeners
    document.getElementById('embalse-level').addEventListener('input', onHydroInput);
    document.getElementById('embalse-level-num').addEventListener('input', onHydroInput);
    document.getElementById('hydro-caudal').addEventListener('input', onHydroInput);
    document.getElementById('hydro-caudal-num').addEventListener('input', onHydroInput);
    document.getElementById('hydro-eff').addEventListener('input', onHydroInput);
    document.getElementById('hydro-eff-num').addEventListener('input', onHydroInput);
    onHydroInput({target:document.getElementById('embalse-level')});

    document.getElementById('control-rods').addEventListener('input', onNuclearInput);
    document.getElementById('control-rods-num').addEventListener('input', onNuclearInput);
    document.getElementById('n_thermal').addEventListener('input', onNuclearInput);
    document.getElementById('n_eff').addEventListener('input', onNuclearInput);
    onNuclearInput({target:document.getElementById('control-rods')});

    document.getElementById('solar-intensity').addEventListener('input', onSolarInput);
    document.getElementById('solar-intensity-num').addEventListener('input', onSolarInput);
    document.getElementById('panel-area').addEventListener('input', onSolarInput);
    document.getElementById('panel-eff').addEventListener('input', onSolarInput);
    document.getElementById('loss-factor').addEventListener('input', onSolarInput);
    onSolarInput({target:document.getElementById('solar-intensity')});

    document.getElementById('wind-speed').addEventListener('input', onWindInput);
    document.getElementById('wind-speed-num').addEventListener('input', onWindInput);
    document.getElementById('swept-area').addEventListener('input', onWindInput);
    document.getElementById('wind-cp').addEventListener('input', onWindInput);
    onWindInput({target:document.getElementById('wind-speed')});

    document.getElementById('biomass-kg').addEventListener('input', calcBio);
    document.getElementById('pc-mj').addEventListener('input', calcBio);
    document.getElementById('bio-eff').addEventListener('input', calcBio);
    calcBio();

    // start small animations so canvases show something
    if(!hidroAnimId) drawHidro();
    if(!nucAnimId) drawNuclear();
    if(!solarAnimId) drawSolar();
    if(!windAnimId) drawWind();
    if(!bioAnimId) drawBio();

    // initial charts update loop: every 800ms push latest data from series to chart datasets
    setInterval(()=> {
      updateChartFromSeries(hidroTimeseriesChart, hidroState.tseries.data);
      updateChartFromSeries(nuclearTimeseriesChart, nucState.tseries.data);
      updateChartFromSeries(solarTimeseriesChart, solarState.tseries.data);
      updateChartFromSeries(windTimeseriesChart, windState.tseries.data);
    }, 800);
  });

  // expose some functions for external calls (console)
  window.showSection = showSection;
  window.onHydroInput = onHydroInput;
  window.onNuclearInput = onNuclearInput;
  window.onSolarInput = onSolarInput;
  window.onWindInput = onWindInput;
  window.calcBio = calcBio;

  </script>
</body>
</html>

